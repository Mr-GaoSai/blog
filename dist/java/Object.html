<!DOCTYPE html>
<html>
<head>

    <meta http-equiv="context-type" content="text/html" charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link rel="shortcut icon" type="image/png" href="/assets/icon.png">
    <link rel="apple-touch-icon" type="image/png" href="/assets/icon.png">
    <meta name="viewport" content="width=device-width,initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
    <link rel="stylesheet" type="text/css" href="/assets/md.css">

    <title>高赛's blog</title>
</head>

<body>

<h2>java中超类Object</h2>

<h3>1. 先摆出java中Object的代码</h3>

<pre><code class="language-java">
package java.lang;
public class Object {
    private static native void registerNatives();
    static {
        registerNatives();
    }
    public final native Class&lt;?&gt; getClass();
    public native int hashCode();
    public boolean equals(Object obj) {
        return (this == obj);
    }
    protected native Object clone() throws CloneNotSupportedException;
    public String toString() {
        return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());
    }
    public final native void notify();
    public final native void notifyAll();
    public final native void wait(long timeout) throws InterruptedException;
    public final void wait(long timeout, int nanos) throws InterruptedException{
        if (timeout &lt; 0) {
            throw new IllegalArgumentException(&quot;timeout value is negative&quot;);
        }
        if (nanos &lt; 0 || nanos &gt; 999999) {
            throw new IllegalArgumentException(
                                &quot;nanosecond timeout value out of range&quot;);
        }
        if (nanos &gt; 0) {
            timeout++;
        }
        wait(timeout);
    }
    public final void wait() throws InterruptedException {
        wait(0);
    }
    protected void finalize() throws Throwable { }
}

</code></pre>

<h3>2. 分析代码</h3>

<p>我们发现用到了native修饰符和很多个函数。</p>

<p>先解释一下native。因为Java语言本身不能对操作系统底层进行访问和操作，但是可以通过JNI接口调用其他语言来实现对底层的访问。native修饰符说明其修饰的方法是一个原生态方法，方法对应的实现不是在当前文件，而是在用其他语言（如C和C++）实现的文件中。</p>

<p>如果对jni感兴趣的可以进一步研究</p>

<h3>3. 各个方法的作用</h3>

<ul>
<li><strong><em>getClass</em></strong> ： 获取对象所属的类，最后派生出来的类。</li>
<li><strong><em>hashCode</em></strong> ： 对象的hash值</li>
<li><strong><em>equals</em></strong> ： 判断两个对象是否相等，默认是看两个对象只想的堆内存地址是否一样</li>
<li><strong><em>clone</em></strong> ： 浅复制，只不过把对象的引用复制了一下，也可以说栈中内存复制。</li>
<li><strong><em>toString</em></strong> ： 对象转化成String，默认类命+16进制hash值</li>
<li><strong><em>notify</em></strong> ：持有对象锁的线程A准备释放对象锁权限，通知jvm唤醒某个竞争该对象锁的线程X</li>
<li><strong><em>notifyAll</em></strong> ：持有对象锁的线程A准备释放对象锁权限，通知jvm唤醒所有竞争该对象锁的线程</li>
<li><strong><em>wait</em></strong> ： 持有对象同步锁的线程A准备释放对象锁，释放cpu资源并进入等待,重新被唤醒后重新竞争获取锁。</li>
<li><strong><em>finalize</em></strong> ： 对象被gc前会调用</li>
</ul>

<h3>4. 注意</h3>

<p>notify和wait方法应该放在被调用的对象的同步锁内执行</p>

<h3>5. 题目<img src="Object.png" alt="" /></h3>

<p><strong><em>输出结果</em></strong>： bac。</p>

<p><strong><em>执行时间</em></strong>：1s</p>

<p><strong><em>题解</em></strong>：理论上线程A和线程B同时启动，此时A沉睡1s，那么B会先获取对象o的对象锁，输出b，然后B调用o.wait(3000)释放对象o的同步，并等待3s，1s后线程A要获取o的同步锁，然后B也已经释放o的同步锁，所以A在1s后获取同步锁，然后输出字母a。此时调用o.notify()，唤醒了B线程，所以输出了c。然而B结束没等待3s线程，恰好等了1s吧。因此两个线程输出顺序bac，执行时间1s。</p>

<h3>Lock锁和Condition条件</h3>

<p>Lock创建Condition，获得Lock锁后才可以调用Condition.await()；因此类似于上面的wait和notify，只不够condition可以有很多个。</p>


</body>
</html>
