<!DOCTYPE html>
<html>
<head>

    <meta http-equiv="context-type" content="text/html" charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link rel="shortcut icon" type="image/png" href="/assets/icon.png">
    <link rel="apple-touch-icon" type="image/png" href="/assets/icon.png">
    <meta name="viewport" content="width=device-width,initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
    <link rel="stylesheet" type="text/css" href="/assets/md.css">

    <title>高赛's blog</title>
</head>

<body>

<h2>java基础知识 之 map</h2>

<p>此文主要讲解HashMap，HashTable，ConcurrentHashMap，TreeMap，LinkedHashMap</p>

<p>高度注意 Map 类集合 K/V 能不能存储 null 值的情况
Hashtable，key：不允许为 null，value：不允许为 null，备注：线程安全
ConcurrentHashMap，key：不允许为 null，value：不允许为 null，备注：分段锁技术
TreeMap，key：不允许为 null，value：允许为 null，备注：线程不安全
HashMap，key：允许为 null，value允许为 null，备注：线程不安全</p>

<h4>1. TreeMap</h4>

<p>这是一个自动排序的平衡二叉树，基于红黑树算法</p>

<p>TreeMap的使用方法</p>

<pre><code class="language-java">//指定排序器  
TreeMap&lt;String, String&gt; treeMap = new TreeMap&lt;String, String&gt;(new 
	Comparator&lt;String&gt;(){  
            /* 
             * int compare(Object o1, Object o2) 返回一个基本类型的整型， 
             * 返回负数表示：o1在前， 
             * 返回0 表示：o1和o2顺序不变， 
             * 返回正数表示：o2在前。 
             */  
            public int compare(String o1, String o2) {
                //指定排序器按照降序排列  
                return o2.compareTo(o1);  
            }     
   });

</code></pre>

<p>插入时间复杂度o(logn)，查找时间复杂度o(logn)，创建时间复杂度o(nlogn)</p>

<p><strong>TreeMap主要用于建造按key排序的键值对</strong>。</p>

<h3>2. HashMap和HashTable</h3>

<p>这两个数据结构经常用于各种面试题，因此需要掌握他们的异同之处。</p>

<h5>共同点： HashMap和HashTable实现的方法都是： 数组 + 链表。</h5>

<h5>共同点： 时间复杂度一样（因为存储采用的方法是一样的）。</h5>

<p>我们先关注他前面那个Hash单词，我们都知道哈希算法，通过哈希算法将key值转化成index角标，每次插入时写入数组的index角标对应的链表，因此插入的时间复杂度为o(1)，那么查找的话先通过Hash算法将key转化成index角标，然后读取当前index下的链表，查找对应的key和value，然而一般情况下链表长度也为1，因此查找的时间复杂度为o(1)。那么可以得出创建的时间复杂度为o(n)。</p>

<p>因为时间复杂度是o(1)，那么面试时经常有各种算法方面的题目，可以考虑这种存储方案。可以将算法的时间复杂度从o(n2)降到o(nlogn)再降到o(n)。接下来我会在文章结尾列举两道算法题目，<strong><em>1.寻找两个集合的交集和并集 2.给定一个整数数组找出其中两个数相加等于目标值。</em></strong></p>

<p>不同之处便是在线程安全和效率和存储的数据方面了</p>

<h5>不同点： HashMap可以接受为null的键值(key)和值(value)，而HashTable则不行。</h5>

<h5>不同点： HashTable是线程安全的，而HashMap是线程不安全的</h5>

<p>HashMap在多线程下因为没有加同步锁，可能会导致插入失败，修改失败，删除失败。（resize情况很好解释）</p>

<p>解释一下为什么会发生插入失败，修改失败，删除失败。</p>

<p>当某些情况下，不同的key值计算出来的index角标相同。那么此时一旦有多个线程里面的key计算出来的index角标相同，那么这时候就会修改同一个链表。</p>

<p>在对应的数组位置存放链表的头结点。对链表而言，<strong>新加入的节点会从头结点加入</strong>。这句话是多线程不安全的关键。</p>

<h3>3. ConCurrentHashMap</h3>

<p>这是一个java5新加的类，它是HashTable的替代，比HashTable的扩展性更好。
因此他的速度和线程安全都是最好的，在多线程下共享数据用它最合适不过了。</p>

<h3>4. LinkedHashMap</h3>

<p>LinkedHashMap和HashMap基本上一样，他依然是线程不安全的</p>

<p>前面多了个Linked单词，它保存了建值对的插入顺序，因此用迭代器遍历Map时，遍历的顺序和插入顺序一样。</p>

<blockquote>
<p>作者：高赛</p>

<p>时间：2017 / 8 / 8</p>
</blockquote>

<hr />

<blockquote>
<p>两道算法题目</p>

<p>2017 ／ 8 ／ 9</p>
</blockquote>

<h3>1. 两个集合的交集</h3>

<pre><code class="language-java">	//三种算法，n2，nlogn，n
	public List&lt;Integer&gt; jiaoji_n2( List&lt;Integer&gt; a, List&lt;Integer&gt; b ){
		List&lt;Integer&gt; ans = new LinkedList&lt;&gt;();
		for( Integer i : a ){
			for( Integer j : b ){
				if( i.equals( j ) ){
					ans.add( i );
				}
			}
		}
		return ans;
	}
	
	public List&lt;Integer&gt; jiaoji_nlogn( List&lt;Integer&gt; a, List&lt;Integer&gt; b ){
		List&lt;Integer&gt; ans = new LinkedList&lt;&gt;();
		if( a.size() &gt; b.size() ){
			List&lt;Integer&gt; tmp = a;
			a = b;
			b = tmp;
		}
		Set&lt;Integer&gt; set = new TreeSet&lt;&gt;();
		for( Integer i : b ){
			set.add( i );
		}
		for( Integer i : a ){
			if( set.contains( i ) ){
				ans.add( i );
			}
		}
		return ans;
	}
	
	public List&lt;Integer&gt; jiaoji_n( List&lt;Integer&gt; a, List&lt;Integer&gt; b ){
		List&lt;Integer&gt; ans = new LinkedList&lt;&gt;();
		if( a.size() &gt; b.size() ){
			List&lt;Integer&gt; tmp = a;
			a = b;
			b = tmp;
		}
		Set&lt;Integer&gt; set = new HashSet&lt;&gt;();
		for( Integer i : b ){
			set.add( i );
		}
		for( Integer i : a ){
			if( set.contains( i ) ){
				ans.add( i );
			}
		}
		return ans;
	}
</code></pre>

<h3>2. 不同的两个数和为n</h3>

<pre><code class="language-java">	//此处只写出时间复杂度为n的算法
	public void sum( List&lt;Integer&gt; a ){
		int sum = 10;
		int size = a.size();
		Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();
		for( int i = 0; i&lt;size; ++i ){
			map.put( a.get( i ) , i);
		}
		//未去重
		for( int i = 0; i&lt;size; ++i ){
			Integer j = map.get( sum - a.get( i ) );
			if( j != null &amp;&amp; i != j ){
				System.out.println( String.format
						(&quot;%d和%d为%d&quot;, a.get( i ), sum-a.get( i ), sum ) );
			}
		}
	}
	
</code></pre>

<h3>HashTable的put方法</h3>

<pre><code>	public synchronized V put(K key, V value) {
        // Make sure the value is not null
        if (value == null) {
            throw new NullPointerException();
        }

        // Makes sure the key is not already in the hashtable.
        Entry&lt;?,?&gt; tab[] = table;
        int hash = key.hashCode();
        int index = (hash &amp; 0x7FFFFFFF) % tab.length;
        @SuppressWarnings(&quot;unchecked&quot;)
        Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];
        for(; entry != null ; entry = entry.next) {
            if ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) {
                V old = entry.value;
                entry.value = value;
                return old;
            }
        }

        addEntry(hash, key, value, index);
        return null;
    }
</code></pre>

<h3>HastTable的get方法</h3>

<pre><code>	public synchronized V get(Object key) {
        Entry&lt;?,?&gt; tab[] = table;
        int hash = key.hashCode();
        int index = (hash &amp; 0x7FFFFFFF) % tab.length;
        for (Entry&lt;?,?&gt; e = tab[index] ; e != null ; e = e.next) {
            if ((e.hash == hash) &amp;&amp; e.key.equals(key)) {
                return (V)e.value;
            }
        }
        return null;
    }
</code></pre>

<h3>HashMap深究</h3>

<p>jdk8更新内容为：HashCode相同的组成链表==》当链表长度大于8时，转化成红黑树</p>

<ul>
<li><strong><em>put方法</em></strong></li>
</ul>

<p><img src="hashmap_put.png" alt="put详细图" /></p>

<ul>
<li><strong><em>get方法</em></strong></li>
</ul>

<h3>HashMap为什么两倍扩容</h3>

<ol>
<li>为了hash的平均分布，table数组利用率更高</li>
<li>为了扩容时数据更好的迁移</li>
</ol>

<p><strong><em>第一个原因解释</em></strong> 我们来分析key如何转化为table[]数组的index</p>

<pre><code>// 除去扩容，链表，树等知识点的伪代码
void put( key, value ){
	int hash = hash( key );
	Node node = new Node( hash, key, value );
	int length = table.length;
	// ( length - 1 ) &amp; hash 这是个关键
	int index = ( length - 1 ) &amp; hash;
	table[index] = node;
}
</code></pre>

<p>length 如果是 2的倍数，那么 length - 1 二进制表达式里面 1 是最多的。因此hash就表示最均匀，table利用率最高</p>

<p><strong><em>第二个原因解释</em></strong> 我们来分析resize方法</p>

<pre><code>// 我仍然写一些伪代码
void resize(){
	oldCap, newCap;
	newCap = oldCap &lt;&lt; 1;
	
	node[] newtable = new node[newCap];
	
	// 下面将 table 中的元素复制进 newtable
	// 为什么直接 复制呢，就普通的Array复制，因为hash对应的index变了，可以通过原因1看出来
	
	for( int j=0; j&lt;oldCap; ++j ){
		if( table[j] != null ){
			// 假设node通过list链接
			node e = table[j];
			//我们肯定会想接下来便利 node 链表，将其中的节点插入到新index对应的链表中。可是我们这时候就用到二倍关系了
			node l1, l2;
			for(){
				if( ( oldCap &amp; e.hash ) &gt; 0 ){
					//插入到l1
				}else{
					// 插入到l2
				}
			}
			//接下来将l1，l2中元素插入新的位置
			//下面就是我要解释的，为什么不用 index = hash( key ) &amp; ( newCap - 1 )
			newtable[j] = l2;
			newtable[j+oldCap] = l1;
		}
	}
}
</code></pre>

<p>因为oldCap是2^n的关系，那么 如果hash的从右数第n为为1时，那么index肯定为 oldIndex + oldCap。hash第n位为0时，那么index肯定为 oldIndex。</p>

<p>因此cap为2的倍数递增，就可以减少扩容时数据的迁移时的时间消耗</p>


</body>
</html>
