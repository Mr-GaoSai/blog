<!DOCTYPE html>
<html>
<head>

    <meta http-equiv="context-type" content="text/html" charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link rel="shortcut icon" type="image/png" href="/assets/icon.png">
    <link rel="apple-touch-icon" type="image/png" href="/assets/icon.png">
    <meta name="viewport" content="width=device-width,initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
    <link rel="stylesheet" type="text/css" href="/assets/md.css">

    <title>高赛's blog</title>
</head>

<body>

<h1>两个有序数组合并为一个有序数组</h1>

<p>
已知：

A[] = [1,2,4,5,7,8,20];

B[] = [0,3,6,9,22];

求：

A与B合并成一个递增数组
</p>

<h3>方法一：</h3>

<p>
新建C数组，将A加入，将B加入，快排C数组。复杂度： (n+m)log(n+m)

<code>java
代码过于简单，此处不写了
</code>

此方法复杂度过高
</p>

<h3>方法二</h3>

<p>
新建C数组（长度:n+m），顺序读取A和B前面的最小值，不断加入C数组。复杂度：n+m

<code>java

public void solve(){
	List&lt;Integer&gt; a = new ArrayList&lt;Integer&gt;(10);
	a.push( 1 );a.push(2);a.push(10);
	List&lt;Integer&gt; b = new ArrayList&lt;Integer&gt;(10);
	b.push( 2 );b.push(11);
	List&lt;Integer&gt; c = new ArrayList&lt;Integer&gt;(10);
	int x, y;
	x = y = 0;
	for( int i=0; i&lt;a.size()+b.size(); ++i ){
		if( x &lt; a.size() &amp;&amp; y &lt; b.size() ){
			if( a[x] &lt; b[y] ){
				c.push( a[x] );
				++x;
			}else{
				c.push(  b[y] );
				++y;
			}
		}else if( x &lt; a.size() ){
			c.push( a[x] );
			++x;
		}else{
			c.push( a[y] );
			++y;
		}
	}
	
	for( int i=0; i&lt;c.size(); ++i ){
		System.out.println( c[i] );
	}
}

</code>
</p>

<h3>方法三</h3>

<p>
此方法是对方法二的优化，非常依赖于数据存储方式

如果a数组长度为n+m的话,那么每次读取a和b的最大值，放到空着的最后面。这样节约了内存空间。性能和速度都挺优秀的.

<code>c

	void merge(int A[], int m, int B[], int n) {
        int count = m + n - 1;
        --m; --n;
        while (m &gt;= 0 &amp;&amp; n &gt;= 0) A[count--] = A[m] &gt; B[n] ? A[m--] : B[n--];
        while (n &gt;= 0) A[count--] = B[n--];
    }

</code>
</p>

<h2>深入探索：n个有序数组排序</h2>

<p>
方法一：最小堆方法

思路：建立最小堆，将n个数组的首数字放入堆，取出堆中最小的数字加入C数组中，将数字对应的数组的下一个数字加入最小堆，如此循环。

由于最小堆维护，并且每次都是n个数字的取数，所以达到了优化。

方法二：分治+上述算法

两两合并，最终获取答案</p>


</body>
</html>
