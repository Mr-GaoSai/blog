<!DOCTYPE html>
<html>
<head>

    <meta http-equiv="context-type" content="text/html" charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link rel="shortcut icon" type="image/png" href="/assets/icon.png">
    <link rel="apple-touch-icon" type="image/png" href="/assets/icon.png">
    <meta name="viewport" content="width=device-width,initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
    <link rel="stylesheet" type="text/css" href="/assets/md.css">

    <title>高赛's blog</title>
</head>

<body>

<h1>go语言</h1>

<h3>import和package</h3>

<pre><code>package main
import &quot;fmt&quot;
func main(){
    fmt.Println( &quot;123&quot; )
}
</code></pre>

<p>分析上面的代码</p>

<p>我们有package关键字，有一个要求，同一个文件夹下package对应的包名必须唯一,_test文件可以加上 _test包名</p>

<p>import关键字，你认为它引入的是包名对吧？其实不然，是文件夹名。我们可以尝试修改go源文件src的fmt文件夹名字至fmt1，这时找不到&rdquo;fmt&rdquo;了。因此import关键字引入的是goroot和gopath下面的文件夹，也可以绝对路径哦。然后文件内使用的使用如果import没有设置别名，使用时用package定义的包名</p>

<h3>strings</h3>

<p>字符串处理包，位于$GOROOT/src/strings文件夹。可以阅读源码，此处简要说明近期遇到的func函数</p>

<pre><code>strings.Contains( a, &quot;12&quot; )

strings.Index(a, &quot;12&quot;)

strings.Compare( a, b )

strings.Split(a, &quot;1&quot;)
</code></pre>

<h3>string的变量</h3>

<pre><code>var a string = nil // error
</code></pre>

<p>string的变量不能为nil</p>

<pre><code>var a = &quot;阿拉123&quot;
fmt.Println( len(a) ) // 输出9。可以见汉字占4个字节

var b = []rune(a)
for _, v := range b {
    fmt.Println( v )
}
fmt.Println( len(b) ) //输出5
</code></pre>

<h3>strconv</h3>

<pre><code>//int to string
strconv.Itoa(v)
//100的16进制
strconv.FormatInt( 100, 16 )
// string to int
k, _ := strconv.Atoi(&quot;1&quot;)
//16进制的64转成int，第三个参数返回结果的bit大小 也就是int8 int16 int32 int64
strconv.ParseInt(&quot;64&quot;, 16, 0)
</code></pre>

<h3>sort</h3>

<pre><code>import &quot;sort&quot;
var a []int
sort.Ints(a) //升序
sort.Reverse( []type ) //反转
sort.Sort([]interface)
</code></pre>

<p>sort排序struct，需要让struct实现sort接口，三个方法.Len,Less,Swap</p>

<pre><code>type Node struct{
    a int
}
type NodeList []Node
func (p NodeList)Swap(i,j int){ t:=p[i];p[i]=p[j];p[j]=t; }
func (p NodeList)Len()int { return len(p) }
func (p NodeList)Less(i,j int)bool {return p[i].a &lt; p[j].a}
//Less函数返回true的话i位置在前，因此上面是升序排序

var ax NodeList
ax = append( ax, Node{1} )
ax = append( ax, Node{2} )
ax = append( ax, Node{-1} )
sort.Sort(ax)
</code></pre>

<h3>[]Slice</h3>

<p>切片,浅复制</p>

<p>[]Slice由数组指针，长度，容量构成</p>

<pre><code>var a []int = make([]int, 5)
var b = a
a[4] = 5
fmt.Println( b[4] )
//上面输出为5.这表明了复制了基本变量，当出现扩容时可能会改变地址，因此可能改变不一致
</code></pre>

<h3>map[type]type</h3>

<p>map数据结构不能排序，遍历的顺序并没有按照插入的顺序</p>

<p>因此我们日常有三种需求，按照插入顺序，按照key顺序，按照value顺序</p>

<p>插入顺序需要维持key的数组</p>

<p>key顺序也是维持key的数组，然后Sort(Key)</p>

<p>value顺序需要维持一个struct，下面的例子</p>

<p>map类型其实是一个指针，因此map间赋值都是浅复制</p>

<pre><code>//按key排序
a := make(map[int]int)
a[1] = 2
a[3] = 4
a[2] = 6
var x []int
for k, v := range a{
    x = append( x, k )
}
sort.Ints(x)
for _, v := range x {
    fmt.Printf( &quot;key:%d--&gt;value:%d\n&quot;, v, a[v] )
}
</code></pre>

<pre><code>//按照value排序
type Node struct {
    key int
    value int
}
type NodeList []Node
func (p NodeList)Swap(i,j int){ t:=p[i];p[i]=p[j];p[j]=t; }
func (p NodeList)Len()int { return len(p) }
func (p NodeList)Less(i,j int)bool {return p[i].value &lt; p[j].value}

a := make( map[int]int )
a[1] = 2
a[2] = 4
a[4] = 1
a[3] = 10
var x NodeList
for k, v : range a {
    x = append( x, Node{ key:k, value:v } )
}
sort.Sort( x )
for _, v := range x {
    fmt.Printf( &quot;key:%d--&gt;value:%d\n&quot;, x.key, x.value )
}
</code></pre>


</body>
</html>
